use std::str::FromStr;
use crate::syntax::*;
use crate::lex::Token;
use lalrpop_util::ErrorRecovery;

grammar<'input>(input: &'input [u8]);

pub Program: Program = {
  <stmts:Stmt*> => Program::new(stmts)
};

Stmt: Statement = {
    <d:Def> => Statement::Def(d),
    <m:Meta> => Statement::Meta(m),
};

Meta: Meta = {
    "meta" <id:Id> <bs:OptionalBindings> <ty:(":" Expr0)?> ":=" <value:Expr0> => {
        Meta::new(id, bs, ty.map(|(_,expr)| expr), value)
    }
};

Def: Def = {
    "def" <id:Id> <bs:OptionalBindings> <ty:(":" Expr0)?> ":=" <value:Expr0> => {
        Def::new(id, bs, ty.map(|(_, expr)| expr), value)
    }
};

Expr0: Box<Expression> = {
  #[precedence(level="0")]
  <p:Pi> => Box::new(Expression::Pi(p)),
  <a:Arrow> => Box::new(Expression::Arrow(a)),
  <fa:FatArrow> => Box::new(Expression::FatArrow(fa)),

  #[precedence(level="1")]
  Expr1,
};

Expr1: Box<Expression> = {
  <mut el:ExprList> => {
    if el.len() == 1 {
        el.pop().unwrap()
    } else {
        Box::new(Expression::App(App::new(el)))
    }
  }
};

Expr2: Box<Expression> = {
  <f:Fun> => Box::new(Expression::Fun(f)),
  <li:LetIn> => Box::new(Expression::LetIn(li)),
  <m:Match> => Box::new(Expression::Match(m)),
  Expr3,
};

Expr3: Box<Expression> = {
  <id:Id> => Box::new(Expression::Id(id)),
  <u:Underscore> => Box::new(Expression::Underscore(u)),
  <p:Paren> => Box::new(Expression::Paren(p)),
  <n:Num> => Box::new(Expression::Num(n)),
  <q:Quote> => Box::new(Expression::Quote(q)),
  <s:Splice> => Box::new(Expression::Splice(s)),
  <r:Raise> => Box::new(Expression::Raise(r)),
};

// (x1 .. xn : X) (y1 .. yn : Y) -> Z
Pi: Pi = {
  <bgs:TypedBindings> "->" <e:Expr0> => {
    Pi::new(bgs, e)
  },
};

// Y -> Z
Arrow: Arrow = {
  <mut s:Expr3*> "->" <t:Expr0> => {
    if s.len() == 1 {
        Arrow::new(s.pop().unwrap(), t)
    } else {
        Arrow::new(Box::new(Expression::App(App::new(s))), t)
    }
  },
};

// Y => Z
FatArrow: FatArrow = {
  <mut s:Expr3*> "=>" <t:Expr0> => {
    if s.len() == 1 {
        FatArrow::new(s.pop().unwrap(), t)
    } else {
        FatArrow::new(Box::new(Expression::App(App::new(s))), t)
    }
  },
};

LetIn: LetIn = {
    "let" <id:Id> <bs:OptionalBindings> <t:(":" Expr0)?> ":=" <v:Expr0> "in" <e:Expr0> => {
        LetIn::new(id, bs, t.map(|(_, t)| t), v, e)
    }
};

Fun: Fun = {
  "fun" <bs:Bindings> "=>" <e:Expr0> => {
    Fun::new(bs, e)
  },
};

// Returns the length of the expression list.
ExprList: Vec<Box<Expression>> = {
  <mut es:Expr3*> <e:Expr2> => {
    es.push(e);
    es
  },
};

Underscore: Underscore = {
  <l:@L> "_" <r:@R> => {
    Underscore::new(l..r)
  }
};

Paren: Paren = {
  "(" <e:Expr0> ")" => {
    Paren::new(e)
  },
};

#[inline]
OptionalBindings: Bindings = {
  Bindings,
  => Bindings::new(vec![]),
}

// Parse a list of typed and untyped binding groups.
#[inline]
Bindings: Bindings = {
  <bgs:BindingGroup+> => Bindings::new(bgs),
};

// Parse a list of typed binding groups.
#[inline]
TypedBindings: TypedBindings = {
  <bgs:TypedBindingGroup+> => TypedBindings::new(bgs),
};

BindingGroup: BindingGroup = {
  <ubg:UntypedBindingGroup> => BindingGroup::Untyped(ubg),
  <tbg:TypedBindingGroup> => BindingGroup::Typed(tbg),
};

// Parse a single binding group without a type.
// x
UntypedBindingGroup: UntypedBindingGroup = {
  <el:Expr3> => UntypedBindingGroup::new(el)
};

// Parse a single binding group with a type.
// (x1 .. xn : A)
TypedBindingGroup: TypedBindingGroup = {
  "(" <el:ExprList> ":" <ty:Expr0> ")" => TypedBindingGroup::new(el, ty)
};

Num: Num = {
  <l:@L> <s:"num"> <r:@R> => {
    Num::new(l..r, Box::from(&input[l..r]))
  }
};

Id: Id = {
  <l:@L> <s:"id"> <r:@R> => {
    Id::new(l..r, Box::from(&input[l..r]))
  }
};

Match: Match = {
  "match" <scrutinee:Expr1> "with" <clauses:MatchClauses> "end" => {
    Match::new(scrutinee, clauses)
  }
};

Quote: Quote = {
  "'" <expr:Expr3> => Quote::new(expr)
};

Splice: Splice = {
  "~" <expr:Expr3> => Splice::new(expr)
};

Raise: Raise = {
  "^" <expr:Expr3> => Raise::new(expr)
};

MatchClauses: Vec<MatchClause> = {
  <first:MatchClause?> <rest:MatchClauseRest*> => {
    let mut clauses = Vec::new();
    if let Some(first_clause) = first {
      clauses.push(first_clause);
    }
    clauses.extend(rest);
    clauses
  }
};

MatchClause: MatchClause = {
  <pattern:Expr1> "~>" <body:Expr0> => {
    MatchClause::new(pattern, body)
  }
};


MatchClauseRest: MatchClause = {
  "|" <pattern:Expr1> "~>" <body:Expr0> => {
    MatchClause::new(pattern, body)
  }
};

extern {
  type Location = usize;

  enum Token {
    "def" => Token::Def,
    "meta" => Token::Meta,
    "rassoc" => Token::RAssoc,
    "lassoc" => Token::LAssoc,
    "let" => Token::Let,
    "in" => Token::In,
    "fun" => Token::Fun,
    "match" => Token::Match,
    "with" => Token::With,
    "end" => Token::End,
    "|" => Token::Pipe,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBrack,
    "]" => Token::RBrack,
    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "~>" => Token::SquigglyArrow,
    ":=" => Token::ColonEqual,
    "," => Token::Comma,
    "." => Token::Period,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "_" => Token::Underscore,
    "'" => Token::Quote,
    "~" => Token::Splice,
    "^" => Token::Raise,
    "num" => Token::Number,
    "id" => Token::Ident,
    "error" => Token::Error,
  }
}
